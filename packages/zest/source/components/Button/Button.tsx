import type {ComponentChild, RenderableProps, VNode} from 'preact';
import {useMemo} from 'preact/hooks';
import {classes, variation} from '@lemon/css';
import {
  signal,
  resolveSignalOrValue,
  type SignalOrValue,
  computed,
} from '@quilted/quilt/signals';

import {Icon, type IconSource} from '../Icon/Icon.tsx';
import {Pressable, type PressableProps} from '../Pressable/Pressable.tsx';

import {useUniqueId} from '../../shared/id.ts';
import {
  useActionScope,
  useConnectedAccessory,
  ConnectedAccessoryContext,
  ConnectedAccessoryReset,
} from '../../shared/actions.tsx';
import {useMenuController} from '../../shared/menus.ts';
import {useContainingForm} from '../../shared/forms.ts';

import type {
  EmphasisValue,
  ActionRoleKeyword,
  BasicAlignmentKeyword,
} from '../../system.ts';

import styles from './Button.module.css';

export type ButtonProps = Omit<PressableProps, 'className' | 'display'> & {
  emphasis?: EmphasisValue;
  loading?: SignalOrValue<boolean>;
  icon?: IconSource | VNode;
  iconAlignment?: BasicAlignmentKeyword;
  detail?: ComponentChild;
  role?: ActionRoleKeyword;
  size?: 'small' | 'auto' | 'large';
  accessory?: ComponentChild;
  inlineSize?: 'content' | 'fill';
};

export function Button({
  ref,
  role,
  disabled,
  emphasis,
  icon,
  iconAlignment,
  detail,
  children,
  size,
  accessory,
  loading,
  inlineSize,
  selected,
  id: explicitId,
  overlay,
  perform,
  onPress,
  ...rest
}: RenderableProps<ButtonProps, HTMLButtonElement | HTMLAnchorElement>) {
  const needsGrid = Boolean(children) && Boolean(detail || icon);
  const connectedAccessory = useConnectedAccessory();
  const menu = useMenuController({optional: true});
  const actionScope = useActionScope({optional: true});
  const form = useContainingForm();

  let finalEmphasis = emphasis;
  let finalRole = role;

  const hasOnPress = typeof onPress === 'function';

  const {activeActions, performingAction} = useMemo(() => {
    if (!hasOnPress) {
      return {};
    }

    const activeActions = signal(0);
    const performingAction = computed(() => activeActions.value > 0);

    return {activeActions, performingAction};
  }, [hasOnPress]);

  const resolvedSelected = resolveSignalOrValue(selected);
  const resolvedDisabled = resolveSignalOrValue(disabled);
  const resolvedLoading =
    resolveSignalOrValue(loading) ||
    (perform === 'submit'
      ? resolveSignalOrValue(form?.submitting.value)
      : undefined) ||
    performingAction?.value;
  const resolvedInert =
    resolvedLoading ||
    actionScope?.active.value ||
    (connectedAccessory === false ? undefined : connectedAccessory.inert);
  const finalDisabled =
    resolvedDisabled || resolvedLoading || resolvedInert || false;

  const idOrAutogeneratedId = useUniqueId('Action', explicitId);

  if (connectedAccessory) {
    finalEmphasis = connectedAccessory.emphasis ?? finalEmphasis;
    finalRole = connectedAccessory.role ?? finalRole;
  }

  const loadingContent = (loading != null ||
    (perform === 'submit' && form != null) ||
    performingAction != null) && (
    <span className={styles.LoadingContent}>
      <LoadingIcon />
    </span>
  );

  let iconContent: ComponentChild = null;
  let needsContentWrapperForLoading = false;

  if (icon) {
    iconContent = resolveIcon(icon);

    if (loadingContent) {
      iconContent = (
        <span className={styles.IconContainer}>
          <span className={styles.Icon}>{iconContent}</span>
          {loadingContent}
        </span>
      );
    }
  } else if (loadingContent) {
    iconContent = loadingContent;
    needsContentWrapperForLoading = true;
  }

  const content = (
    <>
      {iconContent}
      {needsGrid || needsContentWrapperForLoading ? (
        <span className={styles.Content}>{children}</span>
      ) : (
        children
      )}
      {detail}
    </>
  );

  const handlePress: typeof onPress =
    typeof onPress === 'function' && activeActions != null
      ? async (...args) => {
          activeActions.value += 1;

          try {
            const result = await onPress(...args);
            return result;
          } finally {
            activeActions.value -= 1;
          }
        }
      : undefined;

  const handlePressWithActionScope: typeof handlePress =
    handlePress && actionScope
      ? (...args) => actionScope.perform(() => handlePress(...args))
      : handlePress;

  const pressable = (
    <Pressable
      {...(rest as any)}
      ref={ref}
      id={menu || overlay ? idOrAutogeneratedId : explicitId}
      overlay={overlay}
      className={classes(
        styles.Button,
        (finalEmphasis === true || finalEmphasis === 'emphasized') &&
          styles.emphasized,
        finalEmphasis === 'subdued' && styles.subdued,
        finalRole === 'destructive' && styles.destructive,
        menu?.focused.value?.id === idOrAutogeneratedId && styles.focused,
        resolvedSelected && styles.selected,
        resolvedDisabled && styles.disabled,
        resolvedInert && styles.inert,
        resolvedLoading && styles.loading,
        Boolean(icon) && styles.hasIcon,
        iconAlignment && styles[variation('iconAlignment', iconAlignment)],
        inlineSize && styles[variation('inlineSize', inlineSize)],
        Boolean(detail) && styles.hasDetail,
        needsGrid && styles.spacing,
        size && styles[variation('size', size)],
        accessory ? styles.connectedMain : null,
        Boolean(connectedAccessory) && styles.connectedAccessory,
      )}
      disabled={finalDisabled}
      selected={selected}
      display={
        needsGrid
          ? inlineSize === 'fill'
            ? 'grid'
            : 'inlineGrid'
          : inlineSize === 'fill'
            ? 'flex'
            : 'inlineFlex'
      }
      perform={perform}
      onPress={handlePressWithActionScope}
    >
      {content}
    </Pressable>
  );

  return accessory ? (
    <span className={styles.ButtonContainer}>
      <ConnectedAccessoryReset>{pressable}</ConnectedAccessoryReset>
      <ConnectedAccessoryContext
        role={finalRole}
        emphasis={finalEmphasis}
        inert={resolvedInert}
      >
        {accessory}
      </ConnectedAccessoryContext>
    </span>
  ) : (
    pressable
  );
}

function resolveIcon(icon: IconSource | VNode) {
  return typeof icon === 'string' ? <Icon source={icon} /> : icon;
}

function LoadingIcon() {
  return <span aria-label="Loading" className={styles.LoadingIcon} />;
}
