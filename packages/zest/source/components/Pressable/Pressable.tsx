import {
  forwardRef,
  type Ref,
  type ReactNode,
  type PropsWithChildren,
} from 'react';
import {classes, variation} from '@lemon/css';
import {Link, type NavigateTo} from '@quilted/quilt';

import systemStyles from '../../system.module.css';
import {useUniqueId} from '../../utilities/id';
import {useContainingForm} from '../../utilities/forms';
import {
  OverlayContext,
  useOverlayController,
  ariaForOverlay,
} from '../../utilities/overlays';

import styles from './Pressable.module.css';

export type Props = {
  id?: string;
  className?: string;
  display?: 'block' | 'flex' | 'inlineFlex' | 'grid' | 'inlineGrid';
  inlineAlignment?: 'start' | 'end' | 'center';
  disabled?: boolean;
  accessibilityLabel?: string;
  onPress?(): void;
} & (
  | {
      to: NavigateTo;
      target?: 'new' | 'current';
      type?: 'activation' | 'none';
      popover?: ReactNode | false;
      modal?: ReactNode | false;
    }
  | {
      type?: 'activation';
      to?: never;
      target?: never;
      popover?: ReactNode | false;
      modal?: ReactNode | false;
    }
  | {
      type: 'submit' | 'none';
      to?: never;
      target?: never;
      popover?: never;
      modal?: never;
    }
);

export const Pressable = forwardRef<
  HTMLButtonElement | HTMLAnchorElement,
  PropsWithChildren<Props>
>(function Pressable(props, ref) {
  const {id, popover, modal} = props;
  const hasOverlay = popover !== undefined || modal !== undefined;

  const idOrAutogeneratedId = useUniqueId('Action', id);

  let action = (
    <PressableInternal
      {...props}
      ref={ref}
      id={hasOverlay ? idOrAutogeneratedId : id}
    />
  );

  if (popover !== undefined) {
    action = (
      <OverlayContext targetId={idOrAutogeneratedId} overlay={popover}>
        {action}
      </OverlayContext>
    );
  } else if (modal !== undefined) {
    action = (
      <OverlayContext targetId={idOrAutogeneratedId} overlay={modal}>
        {action}
      </OverlayContext>
    );
  }

  return action;
});

export const PressableInternal = forwardRef<
  HTMLButtonElement | HTMLAnchorElement,
  Props
>(function PressableInternal(
  {
    to,
    className: explicitClassName,
    target,
    children,
    display,
    inlineAlignment,
    disabled,
    type,
    onPress,
    accessibilityLabel,
    modal,
    popover,
    ...rest
  }: PropsWithChildren<Props>,
  ref,
) {
  const form = useContainingForm();
  const overlay = useOverlayController({required: false});

  const className = classes(
    display && systemStyles[variation('display', display)],
    inlineAlignment &&
      systemStyles[variation('inlineAlignment', inlineAlignment)],
    styles.Pressable,
    disabled && styles.disabled,
    explicitClassName,
  );

  const handleClick = () => {
    if (onPress) {
      onPress();
    } else if (overlay && (type == null || type === 'activation')) {
      overlay.toggle();
    }
  };

  const resolvedRef: Ref<HTMLAnchorElement | HTMLButtonElement> = overlay
    ? (element) => {
        overlay!.trigger.value = element;

        if (ref == null) return;

        if (typeof ref === 'function') {
          ref(element);
        } else {
          ref.current = element;
        }
      }
    : ref;

  if (to != null) {
    const externalProps =
      target === 'new' ? {target: '_blank', rel: 'noopener noreferrer'} : {};

    return (
      <Link
        ref={resolvedRef as any}
        to={to}
        className={className}
        onClick={handleClick}
        {...externalProps}
        {...rest}
      >
        {children}
      </Link>
    );
  }

  const submitButton = type === 'submit';

  return (
    <button
      ref={resolvedRef as any}
      type={submitButton ? 'submit' : 'button'}
      form={submitButton && form?.nested ? form.id : undefined}
      disabled={disabled}
      className={className}
      onClick={handleClick}
      aria-label={accessibilityLabel}
      {...ariaForOverlay(overlay)}
      {...rest}
    >
      {children}
    </button>
  );
});
